This is my *biggest* bike shed.

* core

  Use =use-package= to install and configure packages. On start,
  =init.el= includes the initial setup for =package.el= and ensures
  that =use-package= is installed.

  This makes sure that =use-package= will install the package if it's
  not already available.

  #+BEGIN_SRC emacs-lisp
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)
  #+END_SRC

  Always compile packages, and use the newest version available with
  =auto-compile=.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
  #+END_SRC

  Update packages every 5 days with =auto-package-update=.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-package-update
      :config
      (setq auto-package-update-interval 5)
      (setq auto-package-update-delete-old-versions t)
      (setq auto-package-update-prompt-before-update t)
      (auto-package-update-maybe))
  #+END_SRC

  Use the $PATH when executing commands from emacs with
  =exec-path-from-shell=.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell)
    (exec-path-from-shell-initialize)
  #+END_SRC

  Help keep ~/.emacs.d clean with =no-littering=.

  #+BEGIN_SRC emacs-lisp
    (use-package no-littering)
    (require 'no-littering)
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  #+END_SRC

  Don't present the usual startup message, and clear the scratch
  buffer.

  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    (setq initial-scratch-message nil)
  #+END_SRC

  When opening a file, start searching at the user's home
  directory.

  #+BEGIN_SRC emacs-lisp
    (setq default-directory "~/")
  #+END_SRC

  Allow 20MB of memory (instead of 0.76MB) before calling
  garbage collection. This means GC runs less often, which speeds
  up some operations.

  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 20000000)
  #+END_SRC

  When opening a file, always follow symlinks.

  #+BEGIN_SRC emacs-lisp
    (setq vc-follow-symlinks t)
  #+END_SRC

  Easily add modes.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/add-auto-mode (mode &rest patterns)
      "Add entries to `auto-mode-alist' to use `MODE' for all given
    file `PATTERNS'."
      (dolist (pattern patterns)
        (add-to-list 'auto-mode-alist (cons pattern mode))))
  #+END_SRC

  OMG. Delete the region (selection) upon char insertion or DEL, pls.

  #+BEGIN_SRC emacs-lisp
    (setq-default delete-selection-mode t)
    (delete-selection-mode 1)
  #+END_SRC

  Configure =recentf=.

  #+BEGIN_SRC emacs-lisp
    (setq-default
      recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:"))
  #+END_SRC

  When something changes a file, automatically refresh the
  buffer containing that file so they can't get out of sync.

  #+BEGIN_SRC emacs-lisp
    (global-auto-revert-mode t)
  #+END_SRC

  Configure newline behaviour

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)
  #+END_SRC

  Never use tabs. Tabs are the devil’s whitespace.

  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+END_SRC

  Prefer shallow indentation.

  #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
  #+END_SRC

  When saving a file in a directory that doesn't exist, offer to
  (recursively) create the file's parent directories.

  #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook
              (lambda ()
                (when buffer-file-name
                  (let ((dir (file-name-directory buffer-file-name)))
                    (when (and (not (file-exists-p dir))
                               (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                      (make-directory dir t))))))
  #+END_SRC

  Don't ask `yes/no?', ask `y/n?'.

  #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  If you save a file that doesn't end with a newline, automatically
  append one.

  #+BEGIN_SRC emacs-lisp
    (setq require-final-newline t)
  #+END_SRC

  When middle-clicking the mouse to yank from the clipboard, insert
  the text where point is, not where the mouse cursor is.

  #+BEGIN_SRC emacs-lisp
    (setq mouse-yank-at-point t)
  #+END_SRC

* platform
** macOS

   Is it a mac?

   #+BEGIN_SRC emacs-lisp
     (defconst *is-a-mac* (eq system-type 'darwin))
   #+END_SRC

   Change up the modifier keys when it's a mac.

   #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
       (setq mac-command-modifier 'meta)
       (setq mac-option-modifier 'none))
   #+END_SRC

   Make the mouse wheel / trackpad scrolling less jerky

   #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
       (setq mouse-wheel-scroll-amount '(1
                                         ((shift) . 5)
                                         ((control))))
       (dolist (multiple '("" "double-" "triple-"))
         (dolist (direction '("right" "left"))
           (global-set-key (read-kbd-macro (concat "<"
           multiple "wheel-" direction ">")) 'ignore))))
   #+END_SRC

   Use =reveal-in-osx-finder=

   #+BEGIN_SRC emacs-lisp
     (when *is-a-mac*
       (use-package reveal-in-osx-finder))
   #+END_SRC

* packages
** searching
*** =rg=

   #+BEGIN_SRC emacs-lisp
     (setq-default grep-highlight-matches t grep-scroll-output t)

     (when *is-a-mac*
       (setq-default locate-command "mdfind"))

     (use-package wgrep)
     (dolist (key (list (kbd "C-c C-q") (kbd "w")))
       (define-key grep-mode-map key 'wgrep-change-to-wgrep-mode))

     (when (executable-find "rg")
       (use-package rg)
       (global-set-key (kbd "M-?") 'rg-project))
   #+END_SRC

*** =projectile=

   Projectile's default binding of =projectile-rg= to =C-c p s s= is
   clunky enough that I rarely use it (and forget it when I need
   it). This binds it to the easier-to-type =C-c p f= to useful
   searches.

   Bind =C-p= to fuzzy-finding files in the current project. We also
   need to explicitly set that in a few other modes.

   I use =ivy= as my completion system.

   When I visit a project with =projectile-switch-project=, the
   default action is to search for a file in that project. I'd rather
   just open up the top-level directory of the project in =dired= and
   find (or create) new files from there.

   I'd like to /always/ be able to recursively fuzzy-search for files,
   not just when I'm in a Projectile-defined project. I use the
   current directory as a project root (if I'm not in a "real"
   project).

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind
       ("C-c v" . 'projectile-rg)
       ("C-c p" . 'projectile-command-map)

       :config
       (setq projectile-completion-system 'ivy)
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-require-project-root nil))

     ;; show dired project root rather than asking for a specific file
     (setq projectile-switch-project-action 'projectile-dired)

     ;; search even if we're not in a "real" project
     (setq projectile-require-project-root nil)

     (projectile-mode t)
   #+END_SRC

*** =ivy=

   #+BEGIN_SRC emacs-lisp
     (require 'ivy)

     (ivy-mode 1)
     (setq ivy-use-virtual-buffers t)
     (setq enable-recursive-minibuffers t)
     (global-set-key (kbd "C-c C-r") 'ivy-resume)
     (global-set-key (kbd "<f6>") 'ivy-resume)
   #+END_SRC

*** =anzu=

    #+BEGIN_SRC emacs-lisp
      (use-package anzu)
      (add-hook 'after-init-hook 'global-anzu-mode)
      (setq anzu-mode-lighter "")
      (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
      (global-set-key [remap query-replace] 'anzu-query-replace)
    #+END_SRC

*** =counsel=

    #+BEGIN_SRC emacs-lisp
      (use-package counsel
        :bind
        ("M-x" . 'counsel-M-x)
        ("C-s" . 'swiper)

        :config
        (use-package flx)
        (use-package smex)

        (ivy-mode 1)
        (setq ivy-use-virtual-buffers t)
        (setq ivy-count-format "(%d/%d) ")
        (setq ivy-initial-inputs-alist nil)
        (setq ivy-re-builders-alist
          '((swiper . ivy--regex-plus)
            (t . ivy--regex-fuzzy))))
   #+END_SRC

** editing
*** =dired=

    #+BEGIN_SRC emacs-lisp
      (setq-default dired-dwim-target t)

      (use-package diredfl)
      (diredfl-global-mode 1)

      (setq dired-recursive-deletes 'top)
      (define-key dired-mode-map [mouse-2] 'dired-find-file)
      (define-key dired-mode-map (kbd "C-c C-q") 'wdired-change-to-wdired-mode)
    #+END_SRC

*** =flycheck=

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck)
      (setq flycheck-display-errors-function #'flycheck-display-error-messages-unless-error-list)

      (global-flycheck-mode 1)
      ;; TODO (flycheck-color-mode-line-mode)
    #+END_SRC

*** =subword=

    Treating terms in CamelCase symbols as separate words makes
    editing a little easier for me, so I like to use =subword-mode=
    everywhere.

    #+BEGIN_SRC emacs-lisp
      (use-package subword
        :config (global-subword-mode 1))
    #+END_SRC

*** =yasnippet=

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet)
      (require 'yasnippet)

      (setq yas-snippet-dirs '("~/.emacs.d/snippets/custom"
                               "~/.emacs.d/snippets/yasnippet"))

      (yas-global-mode 1)
    #+END_SRC

*** =company=

    Use =company-mode= everywhere.

    #+BEGIN_SRC emacs-lisp
      (use-package company)

      (setq company-idle-delay 0.5)
      (setq company-show-numbers t)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      (setq company-tooltip-align-annotations t)
      ;; invert the navigation direction if the the completion popup-isearch-match
      ;; is displayed on top (happens near the bottom of windows)
      (setq company-tooltip-flip-when-above t)

      (add-hook 'after-init-hook 'global-company-mode)
    #+END_SRC

    Use =M-/= for completion.

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "M-/") 'company-complete-common)
    #+END_SRC

*** =hippie-expand=

    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "M-/") 'hippie-expand)

      (setq hippie-expand-try-functions-list
            '(try-complete-file-name-partially
              try-complete-file-name
              try-expand-dabbrev
              try-expand-dabbrev-all-buffers
              try-expand-dabbrev-from-kill))
    #+END_SRC

*** =undo-tree=

   Oh boy, tree-based undo management

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree)
   #+END_SRC

*** =rainbow-delimiters=

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters)
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    #+END_SRC

*** =browse-kill=ring=

    #+BEGIN_SRC emacs-lisp
      (use-package browse-kill-ring)
      (global-set-key (kbd "M-Y") 'browse-kill-ring)
      (define-key browse-kill-ring-mode-map (kbd "C-g") 'browse-kill-ring-quit)
      (define-key browse-kill-ring-mode-map (kbd "M-n") 'browse-kill-ring-forward)
      (define-key browse-kill-ring-mode-map (kbd "M-p") 'browse-kill-ring-previous)
    #+END_SRC

*** =smart-parens=

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :hook ((js-mode . smartparens-mode)
               (ruby-mode . smartparens-mode)
               (emacs-lisp-mode . smartparens-mode)))
    #+END_SRC

*** =show-paren-mode=

    #+BEGIN_SRC emacs-lisp
      (add-hook 'after-init-hook 'show-paren-mode)
    #+END_SRC

*** =expand-region=

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region)
      (global-set-key (kbd "C-=") 'er/expand-region)
    #+END_SRC

*** =move-dup=

    #+BEGIN_SRC emacs-lisp
      (use-package move-dup)
      (global-set-key [M-up] 'md/move-lines-up)
      (global-set-key [M-down] 'md/move-lines-down)
      (global-set-key [M-S-up] 'md/move-lines-up)
      (global-set-key [M-S-down] 'md/move-lines-down)

      (global-set-key (kbd "C-c d") 'md/duplicate-down)
      (global-set-key (kbd "C-c u") 'md/duplicate-up)
    #+END_SRC

*** =whole-line-or-region=

    #+BEGIN_SRC emacs-lisp
      (use-package whole-line-or-region)
      (add-hook 'after-init-hook 'whole-line-or-region-mode)
    #+END_SRC

*** =whitespace-cleanup-mode=

    #+BEGIN_SRC emacs-lisp
      (use-package whitespace-cleanup-mode)
      (add-hook 'after-init-hook 'global-whitespace-cleanup-mode)
    #+END_SRC

*** =vlf=

    Handle opening very large files.

    #+BEGIN_SRC emacs-lisp
      (use-package vlf 
        :ensure t)
    #+END_SRC

*** =highlight-escape-sequences=

    #+BEGIN_SRC emacs-lisp
      (use-package highlight-escape-sequences)
      (add-hook 'after-init-hook 'hes-mode)
    #+END_SRC

*** =which-key=

    =which-key= displays the possible completions for a long
    keybinding. That's really helpful for some modes (like
    =projectile=, for example).

    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :config (which-key-mode))
    #+END_SRC

** moving
*** =switch-window=

    #+BEGIN_SRC emacs-lisp
      (use-package switch-window)
      (setq-default switch-window-shortcut-style 'alphabet)
      (setq-default switch-window-timeout nil)
      (global-set-key (kbd "C-x o") 'switch-window)
    #+END_SRC

    When splitting a window, I invariably want to switch to the new
    window. This makes that automatic.

    #+BEGIN_SRC emacs-lisp
      (defun mrw/split-window-below-and-switch ()
        "Split the window horizontally, then switch to the new pane."
        (interactive)
        (split-window-below)
        (balance-windows)
        (other-window 1))

      (defun mrw/split-window-right-and-switch ()
        "Split the window vertically, then switch to the new pane."
        (interactive)
        (split-window-right)
        (balance-windows)
        (other-window 1))

      (global-set-key (kbd "C-x 2") 'mrw/split-window-below-and-switch)
      (global-set-key (kbd "C-x 3") 'mrw/split-window-right-and-switch)
   #+END_SRC

** version control
*** =magit=

    I use =magit= to handle version control. It's lovely, but I tweak
    a few things:

    - I bring up the status menu with =C-x g=.
    - The default behavior of =magit= is to ask before pushing. I
      haven't had any problems with accidentally pushing, so I'd
      rather not confirm that every time.
    - Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary
      line that goes beyond 50 characters.
    - TODO: On the command line I'll generally push a new branch with
      a plain old =git push=, which automatically creates a tracking
      branch on (usually) =origin=.  Magit, by default, wants me to
      manually specify an upstream branch. This binds =P P= to
      =magit-push-implicitly=, which is just a wrapper around =git
      push -v=. Convenient!

    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :bind
        ("C-x g" . magit-status)

        :config
        (setq magit-push-always-verify nil)
        (setq git-commit-summary-max-length 50))

      (use-package git-blamed)
      (use-package gitignore-mode)
      (use-package gitconfig-mode)
    #+END_SRC

*** =git-timemachine=

    #+BEGIN_SRC emacs-lisp
      (use-package git-timemachine
        :bind ("C-c t" . 'git-timemachine))
    #+END_SRC

*** =diff-hl=

    #+BEGIN_SRC emacs-lisp
      (use-package diff-hl)
      (global-diff-hl-mode)
    #+END_SRC

* languages
** Ruby

   Running tests from within Emacs is awfully convenient.

   #+BEGIN_SRC emacs-lisp
     (use-package rspec-mode)
     (setq rspec-spec-command "bundle exec rspec")
     (setq rspec-use-bundler-when-possible nil)
     (setq rspec-use-spring-when-possible nil)
     (setq rspec-use-opts-file-when-available nil)
     (setq rspec-command-options "--color --format documentation")
     (rspec-install-snippets)
   #+END_SRC

   When assigning the result of a conditional, I like to align the
   expression to match the beginning of the statement instead of
   indenting it all the way to the =if=.

   #+BEGIN_SRC emacs-lisp
     (setq ruby-align-to-stmt-keywords '(def if))
   #+END_SRC

   Ruby method comments are often formatted with Yard.

   #+BEGIN_SRC emacs-lisp
     (use-package yard-mode)
   #+END_SRC

   Insert =end= keywords automatically when I start to define a
   method, class, module, or block.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-end)
   #+END_SRC

   Install and enable =projectile-rails= mode in all Rail-related
   buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile-rails
       :config
       (projectile-rails-global-mode))
   #+END_SRC

   There are a bunch of things I'd like to do when I open a Ruby
   buffer:

   - I don't want to insert an encoding comment.
   - I want to enable =yas=, =rspec=, =yard=, =flycheck=, and
     =projectile-rails=.
   - I'd like my RSpec tests to be run in a random order, and I'd like
     the output to be colored.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ruby-mode-hook
               (lambda ()
                 (setq ruby-insert-encoding-magic-comment nil)
                 (yas-minor-mode)
                 (rspec-mode)
                 (yard-mode)
                 (flycheck-mode)
                 (local-set-key "\r" 'newline-and-indent)
                 (setq rspec-command-options "--color --order random")))

     (setq-default flycheck-disabled-checkers '(ruby-reek))
   #+END_SRC

   I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and
   Vagrantfiles.

   #+BEGIN_SRC emacs-lisp
     (mrw/add-auto-mode
      'ruby-mode
      "\\Gemfile$"
      "\\.rake$"
      "\\.gemspec$"
      "\\Guardfile$"
      "\\Rakefile$"
      "\\Vagrantfile$"
      "\\Vagrantfile.local$")
   #+END_SRC

   When running RSpec tests I'd like to scroll to the first error.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'rspec-compilation-mode-hook
               (lambda ()
                 (make-local-variable 'compilation-scroll-output)
                 (setq compilation-scroll-output 'first-error)))
   #+END_SRC

** HTML

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode)
   #+END_SRC

   If I'm in =web-mode=, I'd like to:

   - Color color-related words with =rainbow-mode=.
   - Still be able to run RSpec tests from =web-mode= buffers.
   - Indent everything with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'web-mode-hook
               (lambda ()
                 (rainbow-mode)
                 (rspec-mode)
                 (setq web-mode-markup-indent-offset 2)))
   #+END_SRC

   Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

   #+BEGIN_SRC emacs-lisp
     (mrw/add-auto-mode 'web-mode
      "\\.erb$"
      "\\.html$"
      "\\.php$"
      "\\.rhtml$")
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode)
   #+END_SRC

   If I'm editing YAML I'm usually in a Rails project. I'd like to be
   able to run the tests from any buffer.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'yaml-mode-hook 'rspec-mode)
   #+END_SRC

* interface

  The =snazzy-theme= is snazzy.

  #+BEGIN_SRC emacs-lisp
    (use-package snazzy-theme
      :config
      (load-theme 'snazzy t))
  #+END_SRC

  The =moody= line is moody.

  #+BEGIN_SRC emacs-lisp
    (use-package moody
      :config
      (setq x-underline-at-descent-line t)
      (moody-replace-mode-line-buffer-identification)
      (moody-replace-vc-mode))
  #+END_SRC

  Use =minions= to hide all minor modes

  #+BEGIN_SRC emacs-lisp
    (use-package minions
      :config
      (setq minions-mode-line-lighter ""
            minions-mode-line-delimiters '("" . ""))
      (minions-mode 1))
  #+END_SRC

  Mode line settings

  #+BEGIN_SRC emacs-lisp
    (line-number-mode t)
    (column-number-mode t)
    (size-indication-mode t)
  #+END_SRC

  Scale text easily with =default-text-scale=.

  #+BEGIN_SRC emacs-lisp
    (use-package default-text-scale
      :config
      (default-text-scale-mode 1))
  #+END_SRC

  A simple visible bell which works in all terminal types

  #+BEGIN_SRC emacs-lisp
    (use-package mode-line-bell
      :config
      (mode-line-bell-mode 1))
  #+END_SRC

  I don't usually use the menu or scroll bar, and they take up useful
  space.

  #+BEGIN_SRC emacs-lisp
    (tool-bar-mode 0)
    (menu-bar-mode 0)
    (scroll-bar-mode -1)
  #+END_SRC

  Turn on syntax highlighting whenever possible.

  #+BEGIN_SRC emacs-lisp
    (global-font-lock-mode t)
  #+END_SRC

  There's a tiny scroll bar that appears in the minibuffer window.
  This disables that:

  #+BEGIN_SRC emacs-lisp
    (set-window-scroll-bars (minibuffer-window) nil nil)
  #+END_SRC

  The default frame title isn't useful. This binds it to the name of
  the current project:

  #+BEGIN_SRC emacs-lisp
    (setq frame-title-format '((:eval (projectile-project-name))))
  #+END_SRC

  Configure font goodness.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/set-font-bau ()
      (interactive)
      (mrw/set-font-size 120))

    (defun mrw/set-font-pairing-station ()
      (interactive)
      (mrw/set-font-size 160))

    (defun mrw/set-font-presentation ()
      (interactive)
      (mrw/set-font-size 220))

    (defun mrw/set-font-size (font-height)
      (custom-set-faces `(default ((t (:height, font-height :family "menlo"))))))

    (mrw/set-font-bau)
  #+END_SRC

  Nicer naming of buffers for files with identical names

  #+BEGIN_SRC emacs-lisp
    (require 'uniquify)
    (setq uniquify-buffer-name-style 'reverse)
    (setq uniquify-separator " • ")
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*")
  #+END_SRC

* utilities

  String utilities missing from core emacs.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/string-all-matches (regex str &optional group)
      "Find all matches for `REGEX' within `STR', returning the full
    match string or group `GROUP'."
      (let ((result nil)
            (pos 0)
            (group (or group 0)))
        (while (string-match regex str pos)
          (push (match-string group str) result)
          (setq pos (match-end group)))
        result))
  #+END_SRC

  Delete the current file and buffer.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/delete-this-file ()
      "Delete the current file, and kill the buffer."
      (interactive)
      (unless (buffer-file-name)
        (error "No file is currently being edited"))
      (when (yes-or-no-p (format "Really delete '%s'?"
                                 (file-name-nondirectory buffer-file-name)))
        (delete-file (buffer-file-name))
        (kill-this-buffer)))

    (global-set-key (kbd "C-x k") 'mrw/delete-this-file)
  #+END_SRC

  Rename the current file.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/rename-this-file-and-buffer (new-name)
      "Renames both current buffer and file it's visiting to
    NEW-NAME."
      (interactive "sNew name: ")
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (unless filename
          (error "Buffer '%s' is not visiting a file!" name))
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (set-visited-file-name new-name)
          (rename-buffer new-name))))
  #+END_SRC

  I futz around with my dotfiles a lot. This binds =C-c e= to quickly
  open my Emacs configuration file.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/visit-emacs-config ()
      (interactive)
      (find-file "~/.emacs.d/config.org"))

    (global-set-key (kbd "C-c e") 'mrw/visit-emacs-config)
  #+END_SRC

  Smart new line behaviour.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/smart-open-line ()
      "Insert an empty line after the current line.
    Position the cursor at its beginning, according to the current
    mode."
      (interactive)
      (move-end-of-line nil)
      (newline-and-indent))

    (defun mrw/smart-open-line-above ()
      "Insert an empty line above the current line.
    Position the cursor at it's beginning, according to the current
    mode."
      (interactive)
      (move-beginning-of-line nil)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode))

    (global-set-key [(shift return)] 'mrw/smart-open-line)
    (global-set-key (kbd "M-o") 'mrw/smart-open-line)
    (global-set-key [(control shift return)] 'mrw/smart-open-line-above)
    (global-set-key (kbd "M-O") 'mrw/smart-open-line-above)
  #+END_SRC

  Join lines, simple!

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-j") (lambda () (interactive) (join-line -1)))
  #+END_SRC

  Show me the whitespace (sometimes)

  #+BEGIN_SRC emacs-lisp
    (defun mrw/show-trailing-whitespace ()
      "Enable display of trailing whitespace in this buffer."
      (setq-local show-trailing-whitespace t))

    (dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
      (add-hook hook 'mrw/show-trailing-whitespace))
  #+END_SRC
