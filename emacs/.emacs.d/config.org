
#+TITLE: just emacs things
#+AUTHOR: Michael Winton
#+OPTIONS: toc:nil num:nil

* =use-package=

  Use =use-package= to install and configure packages. On start, =init.el= includes
  the initial setup for =package.el= and ensures that =use-package= is installed.

  This makes sure that =use-package= will install the package if it's not already
  available.

  #+BEGIN_SRC emacs-lisp
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)
  #+END_SRC

  Always compile packages, and use the newest version available.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
  #+END_SRC

  Help keep ~/.emacs.d clean.

  #+BEGIN_SRC emacs-lisp
    (use-package no-littering)
    (require 'no-littering)
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  #+END_SRC

* Better settings

  Don't present the usual startup message, and clear the scratch
  buffer.
  #+BEGIN_SRC emacs-lisp
    (setq inhibit-startup-message t)
    (setq initial-scratch-message nil)
  #+END_SRC

  When opening a file, start searching at the user's home
  directory.
  #+BEGIN_SRC emacs-lisp
    (setq default-directory "~/")
  #+END_SRC

  Allow 20MB of memory (instead of 0.76MB) before calling
  garbage collection. This means GC runs less often, which speeds
  up some operations.
  #+BEGIN_SRC emacs-lisp
    (setq gc-cons-threshold 20000000)
  #+END_SRC

  Store backups and auto-saved files in
  TEMPORARY-FILE-DIRECTORY (which defaults to /tmp on Unix),
  instead of in the same directory as the file. This means we're
  still making backups, but not where they'll get in the way.
  ---
  WARNING: on most Unix-like systems /tmp is volatile, in-memory
  storage, so your backups won't survive if your computer crashes!
  If you're not willing to take this risk, you shouldn't enable
  this setting.
  #+BEGIN_SRC emacs-lisp
    (setq backup-directory-alist
          `((".*" . ,temporary-file-directory)))
    (setq auto-save-file-name-transforms
          `((".*" ,temporary-file-directory t)))
  #+END_SRC

  Call DELETE-TRAILING-WHITESPACE every time a buffer is saved.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook 'delete-trailing-whitespace)
  #+END_SRC

  Treat CamelCaseSubWords as separate words in every programming
  mode.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'prog-mode-hook 'subword-mode)
  #+END_SRC

  When opening a file, always follow symlinks.
  #+BEGIN_SRC emacs-lisp
    (setq vc-follow-symlinks t)
  #+END_SRC

  When saving a file that starts with `#!', make it executable.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'after-save-hook
              'executable-make-buffer-file-executable-if-script-p)
  #+END_SRC

  Don't assume that sentences should have two spaces after
  periods. This ain't a typewriter.
  #+BEGIN_SRC emacs-lisp
    (setq sentence-end-double-space nil)
  #+END_SRC

  When saving a file in a directory that doesn't exist, offer
  to (recursively) create the file's parent directories.
  #+BEGIN_SRC emacs-lisp
    (add-hook 'before-save-hook
              (lambda ()
                (when buffer-file-name
                  (let ((dir (file-name-directory buffer-file-name)))
                    (when (and (not (file-exists-p dir))
                               (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
                      (make-directory dir t))))))
  #+END_SRC

  Turn on transient-mark-mode.
  #+BEGIN_SRC emacs-lisp
    (transient-mark-mode t)
  #+END_SRC

  If some text is selected, and you type some text, delete the
  selected text and start inserting your typed text.

  #+BEGIN_SRC emacs-lisp
    (delete-selection-mode t)
  #+END_SRC

  If you save a file that doesn't end with a newline,
  automatically append one.

  #+BEGIN_SRC emacs-lisp
    (setq require-final-newline t)
  #+END_SRC

  Add file sizes in human-readable units (KB, MB, etc) to dired
  buffers.
  #+BEGIN_SRC emacs-lisp
    (setq-default dired-listing-switches "-alh")
  #+END_SRC

  Don't ask `yes/no?', ask `y/n?'.
  #+BEGIN_SRC emacs-lisp
    (fset 'yes-or-no-p 'y-or-n-p)
  #+END_SRC

  Turn on syntax highlighting whenever possible.
  #+BEGIN_SRC emacs-lisp
    (global-font-lock-mode t)
  #+END_SRC

  When something changes a file, automatically refresh the
  buffer containing that file so they can't get out of sync.
  #+BEGIN_SRC emacs-lisp
    (global-auto-revert-mode t)
  #+END_SRC

  Visually indicate matching pairs of parentheses.
  #+BEGIN_SRC emacs-lisp
    (show-paren-mode t)
    (setq show-paren-delay 0.0)
  #+END_SRC

  When you double-click on a file in the Mac Finder open it as a
  buffer in the existing Emacs frame, rather than creating a new
  frame just for that file.
  #+BEGIN_SRC emacs-lisp
    (setq ns-pop-up-frames nil)
  #+END_SRC

  When middle-clicking the mouse to yank from the clipboard,
  insert the text where point is, not where the mouse cursor is.
  #+BEGIN_SRC emacs-lisp
    (setq mouse-yank-at-point t)
  #+END_SRC

* macOS Settings

  #+BEGIN_SRC emacs-lisp
    (defconst *is-a-mac* (eq system-type 'darwin))

    (when *is-a-mac*
      (setq mac-command-modifier 'meta)
      (setq mac-option-modifier 'none)
      ;; Make mouse wheel / trackpad scrolling less jerky
      (setq mouse-wheel-scroll-amount '(1
                                        ((shift) . 5)
                                        ((control))))

      (use-package reveal-in-osx-finder)
      )
  #+END_SRC

* Utility Functions

  #+BEGIN_SRC emacs-lisp
        (defun mrw/reload-emacs-config ()
          "reload emacs config file without restarting Emacs"
          (interactive)
          (load-file "~/.emacs.d/init.el") )

        (defun mrw/comment-or-uncomment-region-or-line ()
          "Comments or uncomments the region or the current line if
        there's no active region."
          (interactive)
          (let (beg end)
            (if (region-active-p)
                (setq beg (region-beginning) end (region-end))
              (setq beg (line-beginning-position) end (line-end-position)))
            (comment-or-uncomment-region beg end)))

        (defun mrw/reset-text-size ()
          (interactive)
          (text-scale-set 0))

        (defun mrw/rename-file (new-name)
          (interactive "FNew name: ")
          (let ((filename (buffer-file-name)))
            (if filename
                (progn
                  (when (buffer-modified-p)
                    (save-buffer))
                  (rename-file filename new-name t)
                  (kill-buffer (current-buffer))
                  (find-file new-name)
                  (message "Renamed '%s' -> '%s'" filename new-name))
              (message "Buffer '%s' isn't backed by a file!" (buffer-name)))))

        (defun mrw/generate-scratch-buffer ()
          "Create and switch to a temporary scratch buffer with a random
             name."
          (interactive)
          (switch-to-buffer (make-temp-name "scratch-")))

        (defun mrw/kill-current-buffer ()
          "Kill the current buffer without prompting."
          (interactive)
          (kill-buffer (current-buffer)))

        (defun mrw/add-auto-mode (mode &rest patterns)
          "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
          (dolist (pattern patterns)
            (add-to-list 'auto-mode-alist (cons pattern mode))))

        (defun mrw/region-or-word ()
          (if mark-active
              (buffer-substring-no-properties (region-beginning)
                                              (region-end))
            (thing-at-point 'word)))

        (defun mrw/append-to-path (path)
          "Add a path both to the $PATH variable and to Emacs' exec-path."
          (setenv "PATH" (concat (getenv "PATH") ":" path))
          (add-to-list 'exec-path path))

    (defun mrw/show-buffer-file-name ()
      "Show the full path to the current file in the minibuffer."
      (interactive)
      (let ((file-name (buffer-file-name)))
        (if file-name
            (progn
              (message file-name)
              (kill-new file-name))
          (error "Buffer not visiting a file"))))
  #+END_SRC

* UI Settings
** Tweak window chrome

   I don't usually use the menu or scroll bar, and they take up useful space.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (menu-bar-mode 0)
     (scroll-bar-mode -1)
   #+END_SRC

   There's a tiny scroll bar that appears in the minibuffer window. This disables
   that:

   #+BEGIN_SRC emacs-lisp
     (set-window-scroll-bars (minibuffer-window) nil nil)
   #+END_SRC

   The default frame title isn't useful. This binds it to the name of the current
   project:

   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '((:eval (projectile-project-name))))
   #+END_SRC

** Use fancy lambdas

   Why not?

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode t)
   #+END_SRC

** Load up a theme

   I'm currently using the "snazzy" theme.

   #+BEGIN_SRC emacs-lisp
     (use-package snazzy-theme
       :config
       (load-theme 'snazzy t)

       (setq snazzy-use-variable-pitch nil
             snazzy-height-plus-1 1.0
             snazzy-height-plus-2 1.0
             snazzy-height-plus-3 1.0
             snazzy-height-plus-4 1.0)

       (let ((line (face-attribute 'mode-line :underline)))
         (set-face-attribute 'mode-line          nil :overline   line)
         (set-face-attribute 'mode-line-inactive nil :overline   line)
         (set-face-attribute 'mode-line-inactive nil :underline  line)
         (set-face-attribute 'mode-line          nil :box        nil)
         (set-face-attribute 'mode-line-inactive nil :box        nil)
         (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))

     (load-theme 'snazzy t)
   #+END_SRC

** Use =moody= for a beautiful modeline

   This gives me a truly lovely ribbon-based modeline.

   #+BEGIN_SRC emacs-lisp
     (use-package moody
       :config
       (setq x-underline-at-descent-line t)
       (moody-replace-mode-line-buffer-identification)
       (moody-replace-vc-mode))
   #+END_SRC

** Use =minions= to hide all minor modes

   I never want to see a minor mode, and manually adding =:diminish= to every
   use-package declaration is a hassle. This uses =minions= to hide all the minor
   modes in the modeline. Nice!

   By default there's a =;-)= after the major mode; that's an adorable default, but
   I'd rather skip it.

   #+BEGIN_SRC emacs-lisp
     (use-package minions
       :config
       (setq minions-mode-line-lighter ""
             minions-mode-line-delimiters '("" . ""))
       (minions-mode 1))
   #+END_SRC

** Scroll conservatively

   When point goes outside the window, Emacs usually recenters the buffer point.
   I'm not crazy about that. This changes scrolling behavior to only scroll as far
   as point goes.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC

** Highlight the current line

   =global-hl-line-mode= softly highlights the background color of the line
   containing point. It makes it a bit easier to find point, and it's useful when
   pairing or presenting code.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Highlight uncommitted changes

   Use the =diff-hl= package to highlight changed-and-uncommitted lines when
   programming.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :config
       (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
       (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
   #+END_SRC

* Project management

  I use a few packages in virtually every programming or writing environment to
  manage the project, handle auto-completion, search for terms, and deal with
  version control. That's all in here.

** =ag=

   Set up =ag= for displaying search results.

   #+BEGIN_SRC emacs-lisp
     (use-package ag)
     ;; highlight search output
     (setq-default ag-highlight-search t)
     ;; shortcut for searching projects
     (global-set-key (kbd "M-?") 'ag-project)
   #+END_SRC

** =company=

   Use =company-mode= everywhere.

   #+BEGIN_SRC emacs-lisp
     (use-package company)
     (add-hook 'after-init-hook 'global-company-mode)
   #+END_SRC

   Use =M-/= for completion.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'company-complete-common)
   #+END_SRC

** =dumb-jump=

   The =dumb-jump= package works well enough in a [[https://github.com/jacktasia/dumb-jump#supported-languages][ton of environments]], and it
   doesn't require any additional setup.

   #+BEGIN_SRC emacs-lisp
     (use-package dumb-jump
       :config
       (setq dumb-jump-selector 'ivy))
   #+END_SRC

** =flycheck=

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck)
   #+END_SRC

   ** =magit=

   I use =magit= to handle version control. It's lovely, but I tweak a few things:

   - I bring up the status menu with =C-x g=.
   - The default behavior of =magit= is to ask before pushing. I haven't had any
     problems with accidentally pushing, so I'd rather not confirm that every time.
   - Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
     beyond 50 characters.
   - TODO: On the command line I'll generally push a new branch with a plain old =git
     push=, which automatically creates a tracking branch on (usually) =origin=.
     Magit, by default, wants me to manually specify an upstream branch. This binds
     =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
     -v=. Convenient!

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind
       ("C-x g" . magit-status)

       :config
       (setq magit-push-always-verify nil)
       (setq git-commit-summary-max-length 50))
   #+END_SRC

   I've been playing around with the newly-released =forge= for managing GitHub PRs
   and issues. Seems slick so far.

   #+BEGIN_SRC emacs-lisp
     (use-package ghub)
     (use-package forge)
   #+END_SRC

** =projectile=

   Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
   that I rarely use it (and forget it when I need it). This binds it to the
   easier-to-type =C-c p f= to useful searches.

   Bind =C-p= to fuzzy-finding files in the current project. We also need to
   explicitly set that in a few other modes.

   I use =ivy= as my completion system.

   When I visit a project with =projectile-switch-project=, the default action is
   to search for a file in that project. I'd rather just open up the top-level
   directory of the project in =dired= and find (or create) new files from there.

   I'd like to /always/ be able to recursively fuzzy-search for files, not just
   when I'm in a Projectile-defined project. I use the current directory as a
   project root (if I'm not in a "real" project).

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind
       ("C-c v" . 'projectile-ag)

       :config
       (setq projectile-completion-system 'ivy)
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-require-project-root nil))
   #+END_SRC

** =undo-tree=

   I like tree-based undo management. I only rarely need it, but when I do, oh boy.

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree)
   #+END_SRC

* Programming environments

  Use the $PATH when executing commands from emacs.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell
      :if (memq window-system '(mac ns x))
      :config
      (setq exec-path-from-shell-variables '("PATH"))
      (exec-path-from-shell-initialize))
  #+END_SRC

  I like shallow indentation, but tabs are displayed as 8 characters by default.
  This reduces that.

  #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
  #+END_SRC

  Treating terms in CamelCase symbols as separate words makes editing a little
  easier for me, so I like to use =subword-mode= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package subword
      :config (global-subword-mode 1))
  #+END_SRC

  Compilation output goes to the =*compilation*= buffer. I rarely have that window
  selected, so the compilation output disappears past the bottom of the window.
  This automatically scrolls the compilation window so I can always see the
  output.

  #+BEGIN_SRC emacs-lisp
    (setq compilation-scroll-output t)
  #+END_SRC

** CSS and Sass

   Indent by 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (use-package css-mode
       :config
       (setq css-indent-offset 2))
   #+END_SRC

   Don't compile the current SCSS file every time I save.

   #+BEGIN_SRC emacs-lisp
     (use-package scss-mode
       :config
       (setq scss-compile-at-save nil))
   #+END_SRC

** Haml and Slim

   Install the Haml and Slim packages.

   #+BEGIN_SRC emacs-lisp
     (use-package haml-mode)
     (use-package slim-mode)
   #+END_SRC

   If I'm editing Haml or Slim templates I'm probably in a Rails project. In that
   case, I'd like to still be able to run my tests from the appropriate buffers.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'slim-mode-hook 'rspec-mode)
     (add-hook 'haml-mode-hook 'rspec-mode)
   #+END_SRC

** Lisps

   I like to use =paredit= in Lisp modes to balance parentheses (and more!).

   #+BEGIN_SRC emacs-lisp
     (use-package paredit)
   #+END_SRC

   =rainbow-delimiters= is convenient for coloring matching parentheses.

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters)
   #+END_SRC

   All the lisps have some shared features, so we want to do the same things for
   all of them. That includes using =paredit=, =rainbow-delimiters=, and
   highlighting the whole expression when point is on a parenthesis.

   #+BEGIN_SRC emacs-lisp
     (setq lispy-mode-hooks
           '(clojure-mode-hook
             emacs-lisp-mode-hook
             lisp-mode-hook
             scheme-mode-hook))

     (dolist (hook lispy-mode-hooks)
       (add-hook hook (lambda ()
                        (setq show-paren-style 'expression)
                        (paredit-mode)
                        (rainbow-delimiters-mode))))
   #+END_SRC

   If I'm writing in Emacs lisp I'd like to use =eldoc-mode= to display
   documentation.

   #+BEGIN_SRC emacs-lisp
     (use-package eldoc
       :config
       (add-hook 'emacs-lisp-mode-hook 'eldoc-mode))
   #+END_SRC

   I also like using =flycheck-package= to ensure that my Elisp packages are
   correctly formatted.

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-package)

     (eval-after-load 'flycheck
       '(flycheck-package-setup))
   #+END_SRC

** Ruby and RSpec

   Running tests from within Emacs is awfully convenient.

   #+BEGIN_SRC emacs-lisp
     (use-package rspec-mode)
     (setq rspec-spec-command "bundle exec rspec")
     (setq rspec-use-bundler-when-possible nil)
     (setq rspec-use-spring-when-possible nil)
     (setq rspec-use-opts-file-when-available nil)
     (setq rspec-command-options "--color --format documentation")
   #+END_SRC

   When assigning the result of a conditional, I like to align the expression to
   match the beginning of the statement instead of indenting it all the way to the
   =if=.

   #+BEGIN_SRC emacs-lisp
     (setq ruby-align-to-stmt-keywords '(def if))
   #+END_SRC

   Ruby method comments are often formatted with Yard.

   #+BEGIN_SRC emacs-lisp
     (use-package yard-mode)
   #+END_SRC

   Insert =end= keywords automatically when I start to define a method, class,
   module, or block.

   #+BEGIN_SRC emacs-lisp
     (use-package ruby-end)
   #+END_SRC

   Install and enable =projectile-rails= mode in all Rail-related buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package projectile-rails
       :config
       (projectile-rails-global-mode))
   #+END_SRC

   There are a bunch of things I'd like to do when I open a Ruby buffer:

   - I don't want to insert an encoding comment.
   - I want to enable =yas=, =rspec=, =yard=, =flycheck=, and =projectile-rails=.
   - I'd like my RSpec tests to be run in a random order, and I'd like the output
     to be colored.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'ruby-mode-hook
               (lambda ()
                 (setq ruby-insert-encoding-magic-comment nil)
                 (yas-minor-mode)
                 (rspec-mode)
                 (yard-mode)
                 (flycheck-mode)
                 (local-set-key "\r" 'newline-and-indent)
                 (setq rspec-command-options "--color --order random")))
   #+END_SRC

   I associate =ruby-mode= with Gemfiles, gemspecs, Rakefiles, and Vagrantfiles.

   #+BEGIN_SRC emacs-lisp
     (mrw/add-auto-mode
      'ruby-mode
      "\\Gemfile$"
      "\\.rake$"
      "\\.gemspec$"
      "\\Guardfile$"
      "\\Rakefile$"
      "\\Vagrantfile$"
      "\\Vagrantfile.local$")
   #+END_SRC

   When running RSpec tests I'd like to scroll to the first error.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'rspec-compilation-mode-hook
               (lambda ()
                 (make-local-variable 'compilation-scroll-output)
                 (setq compilation-scroll-output 'first-error)))
   #+END_SRC

** =sh=

   Indent with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sh-mode-hook
               (lambda ()
                 (setq sh-basic-offset 2
                       sh-indentation 2)))
   #+END_SRC

** =web-mode=

   #+BEGIN_SRC emacs-lisp
     (use-package web-mode)
   #+END_SRC

   If I'm in =web-mode=, I'd like to:

   - Color color-related words with =rainbow-mode=.
   - Still be able to run RSpec tests from =web-mode= buffers.
   - Indent everything with 2 spaces.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'web-mode-hook
               (lambda ()
                 (rainbow-mode)
                 (rspec-mode)
                 (setq web-mode-markup-indent-offset 2)))
   #+END_SRC

   Use =web-mode= with embedded Ruby files, regular HTML, and PHP.

   #+BEGIN_SRC emacs-lisp
     (mrw/add-auto-mode
      'web-mode
      "\\.erb$"
      "\\.html$"
      "\\.php$"
      "\\.rhtml$")
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode)
   #+END_SRC

   If I'm editing YAML I'm usually in a Rails project. I'd like to be able to run
   the tests from any buffer.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'yaml-mode-hook 'rspec-mode)
   #+END_SRC

* Terminal

  I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

  #+BEGIN_SRC emacs-lisp
    (use-package multi-term)
    (global-set-key (kbd "C-c t") 'multi-term)
  #+END_SRC

  Use a login shell:

  #+BEGIN_SRC emacs-lisp
    (setq multi-term-program-switches "--login")
  #+END_SRC

  I add a bunch of hooks to =term-mode=:

  - I'd like links (URLs, etc) to be clickable.
  - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
    the buffer but isn't sent to the shell process. This correctly binds =C-y= and
    middle-click to yank the way we'd expect.
  - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
  - I don't want to perform =yasnippet= expansion when tab-completing.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/term-paste (&optional string)
      (interactive)
      (process-send-string
       (get-buffer-process (current-buffer))
       (if string string (current-kill 0))))

    (add-hook 'term-mode-hook
              (lambda ()
                (goto-address-mode)
                (define-key term-raw-map (kbd "C-y") 'mrw/term-paste)
                (define-key term-raw-map (kbd "<mouse-2>") 'mrw/term-paste)
                (define-key term-raw-map (kbd "M-o") 'other-window)
                (setq yas-dont-activate t)))
  #+END_SRC

* Org-mode

  #+BEGIN_SRC emacs-lisp
    (use-package org)
  #+END_SRC

** Display preferences

   I like to see an outline of pretty bullets instead of a list of asterisks.

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :init
       (add-hook 'org-mode-hook 'org-bullets-mode))
   #+END_SRC

   Use syntax highlighting in source blocks while editing.

   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively t)
   #+END_SRC

   Make TAB act as if it were issued in a buffer of the language's major mode.

   #+BEGIN_SRC emacs-lisp
     (setq org-src-tab-acts-natively t)
   #+END_SRC

   When editing a code snippet, use the current window rather than popping open a
   new one (which shows the same information).

   #+BEGIN_SRC emacs-lisp
     (setq org-src-window-setup 'current-window)
   #+END_SRC

   Quickly insert a block of elisp:

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist
                  '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
   #+END_SRC

   Allow =babel= to evaluate Emacs lisp and Ruby.

   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)))
   #+END_SRC

   Don't ask before evaluating code blocks.

   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

* Editing

  Setup multiple cursors.

  #+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-+") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
    (global-set-key (kbd "C-c m c") 'mc/edit-lines)
    (global-set-key (kbd "C-c m e") 'mc/edit-ends-of-lines)
    (global-set-key (kbd "C-c m a") 'mc/edit-beginnings-of-lines)
  #+END_SRC

  Setup expand-region

  #+BEGIN_SRC emacs-lisp
    (use-package expand-region)
    (global-set-key (kbd "C-=") 'er/expand-region)
  #+END_SRC

  Cut/copy the current line if no region is active

  #+BEGIN_SRC emacs-lisp
    (use-package whole-line-or-region)
    (add-hook 'after-init-hook 'whole-line-or-region-mode)
  #+END_SRC

* Moving

  Configure =projectile=

  #+BEGIN_SRC emacs-lisp
    ;; show dired project root rather than asking for a specific file
    (setq projectile-switch-project-action 'projectile-dired)

    ;; search even if we're not in a "real" project
    (setq projectile-require-project-root nil)

    ;; set preferred projectile prefix
    (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  #+END_SRC

  Switch windows visually.

  #+BEGIN_SRC emacs-lisp
    (use-package switch-window)
    (setq-default switch-window-shortcut-style 'alphabet)
    (setq-default switch-window-timeout nil)
    (global-set-key (kbd "C-x o") 'switch-window)
  #+END_SRC

* Writing prose

** Enable spell-checking in the usual places

   I want to make sure that I've enabled spell-checking if I'm editing text,
   composing an email, or authoring a Git commit.

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :config
       (add-hook 'text-mode-hook 'turn-on-auto-fill)
       (add-hook 'gfm-mode-hook 'flyspell-mode)
       (add-hook 'org-mode-hook 'flyspell-mode)

       (add-hook 'git-commit-mode-hook 'flyspell-mode)
       (add-hook 'mu4e-compose-mode-hook 'flyspell-mode))
   #+END_SRC

** Look up definitions in Webster 1913

   I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
   loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
   so these definitions are a lot of fun.

   #+BEGIN_SRC emacs-lisp
     (defun mrw/dictionary-prompt ()
       (read-string
        (format "Word (%s): " (or (mrw/region-or-word) ""))
        nil
        nil
        (mrw/region-or-word)))

     (defun mrw/dictionary-define-word ()
       (interactive)
       (let* ((word (mrw/dictionary-prompt))
              (buffer-name (concat "Definition: " word)))
         (with-output-to-temp-buffer buffer-name
           (shell-command (format "sdcv -n %s" word) buffer-name))))

     (define-key global-map (kbd "C-x w") 'mrw/dictionary-define-word)
   #+END_SRC

** Look up words in a thesaurus

   Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
   =C-x s= searches for synonyms.

   #+BEGIN_SRC emacs-lisp
     (use-package synosaurus)
     (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
     (add-hook 'after-init-hook #'synosaurus-mode)
     (define-key global-map "\C-xs" 'synosaurus-lookup)
   #+END_SRC

** Wrap paragraphs automatically

   =AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
   a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
   Markdown, or Org.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'auto-fill-mode)
     (add-hook 'gfm-mode-hook 'auto-fill-mode)
     (add-hook 'org-mode-hook 'auto-fill-mode)
   #+END_SRC

** Cycle between spacing alternatives

   Successive calls to =cycle-spacing= rotate between changing the whitespace
   around point to:

   - A single space,
   - No spaces, or
   - The original spacing.

   Binding this to =M-SPC= is strictly better than the original binding of
   =just-one-space=.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-SPC") 'cycle-spacing)
   #+END_SRC

** Linting prose

   I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
   checker that runs proselint in texty buffers and displays my errors.

   #+BEGIN_SRC emacs-lisp
     (require 'flycheck)

     (flycheck-define-checker proselint
       "A linter for prose."
       :command ("proselint" source-inplace)
       :error-patterns
       ((warning line-start (file-name) ":" line ":" column ": "
                 (id (one-or-more (not (any " "))))
                 (message (one-or-more not-newline)
                          (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                 line-end))
       :modes (text-mode markdown-mode gfm-mode org-mode))

     (add-to-list 'flycheck-checkers 'proselint)
   #+END_SRC

   Use flycheck in the appropriate buffers:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'markdown-mode-hook #'flycheck-mode)
     (add-hook 'gfm-mode-hook #'flycheck-mode)
     (add-hook 'text-mode-hook #'flycheck-mode)
     (add-hook 'org-mode-hook #'flycheck-mode)
   #+END_SRC

** Enable region case modification

   #+BEGIN_SRC emacs-lisp
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

* =dired=

  Kill buffers of files/directories that are deleted in =dired=.

  #+BEGIN_SRC emacs-lisp
    (setq dired-clean-up-buffers-too t)
  #+END_SRC

  Always copy directories recursively instead of asking every time.

  #+BEGIN_SRC emacs-lisp
    (setq dired-recursive-copies 'always)
  #+END_SRC

  Ask before recursively /deleting/ a directory, though.

  #+BEGIN_SRC emacs-lisp
    (setq dired-recursive-deletes 'top)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package diredfl)
    (diredfl-global-mode) ;; make dired pretty

    (use-package diff-hl)
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode) ;; show git changes in dired
  #+END_SRC

* Editing settings

** Quickly visit Emacs configuration

   I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
   Emacs configuration file.

   #+BEGIN_SRC emacs-lisp
     (defun mrw/visit-emacs-config ()
       (interactive)
       (find-file "~/.emacs.d/config.org"))

     (global-set-key (kbd "C-c e") 'mrw/visit-emacs-config)
   #+END_SRC

** Always kill current buffer

   Assume that I always want to kill the current buffer when hitting =C-x k=.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'mrw/kill-current-buffer)
   #+END_SRC

** Set up =helpful=

   The =helpful= package provides, among other things, more context in Help
   buffers.

   #+BEGIN_SRC emacs-lisp
     (use-package helpful)

     (global-set-key (kbd "C-h f") #'helpful-callable)
     (global-set-key (kbd "C-h v") #'helpful-variable)
     (global-set-key (kbd "C-h k") #'helpful-key)
   #+END_SRC

** Look for executables in =/usr/local/bin=

   #+BEGIN_SRC emacs-lisp
     (mrw/append-to-path "/usr/local/bin")
   #+END_SRC

** Save my location within a file

   Using =save-place-mode= saves the location of point for every file I visit. If I
   close the file or close the editor, then later re-open it, point will be at the
   last place I visited.

   #+BEGIN_SRC emacs-lisp
     (save-place-mode t)
   #+END_SRC

** Always indent with spaces

   Never use tabs. Tabs are the devil’s whitespace.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Install and configure =which-key=

   =which-key= displays the possible completions for a long keybinding. That's
   really helpful for some modes (like =projectile=, for example).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config (which-key-mode))
   #+END_SRC

** Configure =yasnippet=

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet)
   #+END_SRC

   I keep my snippets in =~/.emacs/snippets=, and I always want =yasnippet=
   enabled.

   #+BEGIN_SRC emacs-lisp
     (setq yas-snippet-dirs '("~/.emacs.d/snippets"))
     (yas-global-mode 1)
   #+END_SRC

   # I /don’t/ want =yas= to automatically indent the snippets it inserts. Sometimes
   # this looks pretty bad (when indenting org-mode, for example, or trying to guess
   # at the correct indentation for Python).

   #+BEGIN_SRC emacs-lisp
     (setq yas/indent-line nil)
   #+END_SRC

** Configure =ivy= and =counsel=

   I use =ivy= and =counsel= as my completion framework.

   This configuration:

   - Uses =counsel-M-x= for command completion,
   - Replaces =isearch= with =swiper=,
   - Uses =smex= to maintain history,
   - Enables fuzzy matching everywhere except swiper (where it's thoroughly
     unhelpful), and
   - Includes recent files in the switch buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :bind
       ("M-x" . 'counsel-M-x)
       ("C-s" . 'swiper)

       :config
       (use-package flx)
       (use-package smex)

       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-initial-inputs-alist nil)
       (setq ivy-re-builders-alist
             '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))))
   #+END_SRC

** Switch and rebalance windows when splitting

   When splitting a window, I invariably want to switch to the new window. This
   makes that automatic.

   #+BEGIN_SRC emacs-lisp
     (defun mrw/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun mrw/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'mrw/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'mrw/split-window-right-and-switch)
   #+END_SRC

** Mass editing of =grep= results

   I like the idea of mass editing =grep= results the same way I can edit filenames
   in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
   results and =C-c C-c= to stop, just like in =dired=.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep)

     (eval-after-load 'grep
       '(define-key grep-mode-map
          (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

     (eval-after-load 'wgrep
       '(define-key grep-mode-map
          (kbd "C-c C-c") 'wgrep-finish-edit))

     (setq wgrep-auto-save-buffer t)
   #+END_SRC

** Use projectile everywhere

   #+BEGIN_SRC emacs-lisp
     (projectile-global-mode)
   #+END_SRC

* Set custom keybindings

  Just a few handy functions.

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-w") 'backward-kill-word)
    (global-set-key (kbd "M-o") 'other-window)
  #+END_SRC
