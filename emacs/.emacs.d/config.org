
#+TITLE: just emacs things
#+AUTHOR: Michael Winton
#+OPTIONS: toc:nil num:nil

* settings

  Use =use-package= to install and configure packages. On start,
  =init.el= includes the initial setup for =package.el= and ensures
  that =use-package= is installed.

  This makes sure that =use-package= will install the package if it's
  not already available.

  #+BEGIN_SRC emacs-lisp
    (require 'use-package-ensure)
    (setq use-package-always-ensure t)
  #+END_SRC

  Always compile packages, and use the newest version available with
  =auto-compile=.

  #+BEGIN_SRC emacs-lisp
    (use-package auto-compile
      :config (auto-compile-on-load-mode))

    (setq load-prefer-newer t)
  #+END_SRC

  Use the $PATH when executing commands from emacs with
  =exec-path-from-shell=.

  #+BEGIN_SRC emacs-lisp
    (use-package exec-path-from-shell)
    (require 'exec-path-from-shell)
    (exec-path-from-shell-initialize)
  #+END_SRC

  Help keep ~/.emacs.d clean with =no-littering=.

  #+BEGIN_SRC emacs-lisp
    (use-package no-littering)
    (require 'no-littering)
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  #+END_SRC

* macOS

  Is it a mac?

  #+BEGIN_SRC emacs-lisp
    (defconst *is-a-mac* (eq system-type 'darwin))
  #+END_SRC

  Change up the modifier keys when it's a mac.

  #+BEGIN_SRC emacs-lisp
    (when *is-a-mac*
      (setq mac-command-modifier 'meta)
      (setq mac-option-modifier 'none))
  #+END_SRC

  Make the mouse wheel / trackpad scrolling less jerky

  #+BEGIN_SRC emacs-lisp
    (when *is-a-mac*
      (setq mouse-wheel-scroll-amount '(1
                                        ((shift) . 5)
                                        ((control))))
      (dolist (multiple '("" "double-" "triple-"))
        (dolist (direction '("right" "left"))
          (global-set-key (read-kbd-macro (concat "<" multiple "wheel-" direction ">")) 'ignore))))
  #+END_SRC

* packages
** =ag= and =rg=

   #+BEGIN_SRC emacs-lisp
     (setq-default grep-highlight-matches t
                   grep-scroll-output t)

     (when *is-a-mac*
       (setq-default locate-command "mdfind"))

     (use-package wgrep)
     (dolist (key (list (kbd "C-c C-q") (kbd "w")))
       (define-key grep-mode-map key 'wgrep-change-to-wgrep-mode))

     (when (executable-find "ag")
       (use-package ag)
       (use-package wgrep-ag)
       (setq-default ag-highlight-search t)
       (global-set-key (kbd "M-?") 'ag-project))

     (when (executable-find "rg")
       (use-package rg)
       (use-package deadgrep)
       (global-set-key (kbd "M-?") 'rg-project))
   #+END_SRC

** [TODO] =ibuffer=
** ==flycheck==

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck)
     (setq flycheck-display-errors-function #'flycheck-display-error-messages-unless-error-list)

     (global-flycheck-mode 1)
     ;; TODO (flycheck-color-mode-line-mode)
   #+END_SRC

** =uniquify=

   Nicer naming of buffers for files with identical names

   #+BEGIN_SRC emacs-lisp
     (require 'uniquify)

     (setq uniquify-buffer-name-style 'reverse)
     (setq uniquify-separator " â€¢ ")
     (setq uniquify-after-kill-buffer-p t)
     (setq uniquify-ignore-buffers-re "^\\*")
   #+END_SRC

** =subword=

   Treating terms in CamelCase symbols as separate words makes editing a little
   easier for me, so I like to use =subword-mode= everywhere.

   #+BEGIN_SRC emacs-lisp
     (use-package subword
       :config (global-subword-mode 1))
   #+END_SRC

** =dired=

   #+BEGIN_SRC emacs-lisp
     (setq-default dired-dwim-target t)

     (use-package diredfl)
     (diredfl-global-mode 1)

     (use-package diff-hl)
     (diff-hl-dired-mode 1)

     (setq dired-recursive-deletes 'top)
     (define-key dired-mode-map [mouse-2] 'dired-find-file)
     (define-key dired-mode-map (kbd "C-c C-q") 'wdired-change-to-wdired-mode)
   #+END_SRC

** =magit=

   I use =magit= to handle version control. It's lovely, but I tweak a few things:

   - I bring up the status menu with =C-x g=.
   - The default behavior of =magit= is to ask before pushing. I haven't had any
     problems with accidentally pushing, so I'd rather not confirm that every time.
   - Per [[http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html][tpope's suggestions]], highlight commit text in the summary line that goes
     beyond 50 characters.
   - TODO: On the command line I'll generally push a new branch with a plain old =git
     push=, which automatically creates a tracking branch on (usually) =origin=.
     Magit, by default, wants me to manually specify an upstream branch. This binds
     =P P= to =magit-push-implicitly=, which is just a wrapper around =git push
     -v=. Convenient!

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind
       ("C-x g" . magit-status)

       :config
       (setq magit-push-always-verify nil)
       (setq git-commit-summary-max-length 50))

     (use-package git-blamed)
     (use-package gitignore-mode)
     (use-package gitconfig-mode)
   #+END_SRC

** =projectile=

   Projectile's default binding of =projectile-ag= to =C-c p s s= is clunky enough
   that I rarely use it (and forget it when I need it). This binds it to the
   easier-to-type =C-c p f= to useful searches.

   Bind =C-p= to fuzzy-finding files in the current project. We also need to
   explicitly set that in a few other modes.

   I use =ivy= as my completion system.

   When I visit a project with =projectile-switch-project=, the default action is
   to search for a file in that project. I'd rather just open up the top-level
   directory of the project in =dired= and find (or create) new files from there.

   I'd like to /always/ be able to recursively fuzzy-search for files, not just
   when I'm in a Projectile-defined project. I use the current directory as a
   project root (if I'm not in a "real" project).

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :bind
       ("C-c v" . 'projectile-ag)
       ("C-c p" . 'projectile-command-map)

       :config
       (setq projectile-completion-system 'ivy)
       (setq projectile-switch-project-action 'projectile-dired)
       (setq projectile-require-project-root nil))
   #+END_SRC

** =counsel=

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :bind
       ("M-x" . 'counsel-M-x)
       ("C-s" . 'swiper)

       :config
       (use-package flx)
       (use-package smex)

       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-initial-inputs-alist nil)
       (setq ivy-re-builders-alist
             '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))))
   #+END_SRC

** =company=

   Use =company-mode= everywhere.

   #+BEGIN_SRC emacs-lisp
     (use-package company)
     (add-hook 'after-init-hook 'global-company-mode)
   #+END_SRC

   Use =M-/= for completion.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'company-complete-common)
   #+END_SRC

** =hippie-expand=

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-/") 'hippie-expand)

     (setq hippie-expand-try-functions-list
           '(try-complete-file-name-partially
             try-complete-file-name
             try-expand-dabbrev
             try-expand-dabbrev-all-buffers
             try-expand-dabbrev-from-kill))
   #+END_SRC

** =switch-window=

   #+BEGIN_SRC emacs-lisp
     (use-package switch-window)
     (setq-default switch-window-shortcut-style 'alphabet)
     (setq-default switch-window-timeout nil)
     (global-set-key (kbd "C-x o") 'switch-window)
   #+END_SRC

   When splitting a window, I invariably want to switch to the new window. This
   makes that automatic.

   #+BEGIN_SRC emacs-lisp
     (defun mrw/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun mrw/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'mrw/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'mrw/split-window-right-and-switch)
   #+END_SRC

** =recentf=

   #+BEGIN_SRC emacs-lisp
     (setq-default
      recentf-max-saved-items 1000
      recentf-exclude '("/tmp/" "/ssh:"))
   #+END_SRC

** ==global-auto-revert-mode==

   When something changes a file, automatically refresh the
   buffer containing that file so they can't get out of sync.

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC

** =undo-tree=

   Oh boy, tree-based undo management

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree)
   #+END_SRC

** =rainbow-delimiters=

   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-delimiters)
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
   #+END_SRC

** =browse-kill=ring=

   #+BEGIN_SRC emacs-lisp
     (use-package browse-kill-ring)
     (global-set-key (kbd "M-Y") 'browse-kill-ring)
     (define-key browse-kill-ring-mode-map (kbd "C-g") 'browse-kill-ring-quit)
     (define-key browse-kill-ring-mode-map (kbd "M-n") 'browse-kill-ring-forward)
     (define-key browse-kill-ring-mode-map (kbd "M-p") 'browse-kill-ring-previous)
   #+END_SRC

** =show-paren-mode=

   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-init-hook 'show-paren-mode)
   #+END_SRC

** =expand-region=

   #+BEGIN_SRC emacs-lisp
     (use-package expand-region)
     (global-set-key (kbd "C-=") 'er/expand-region)
   #+END_SRC

** =move-dup=

   #+BEGIN_SRC emacs-lisp
     (use-package move-dup)
     (global-set-key [M-up] 'md/move-lines-up)
     (global-set-key [M-down] 'md/move-lines-down)
     (global-set-key [M-S-up] 'md/move-lines-up)
     (global-set-key [M-S-down] 'md/move-lines-down)

     (global-set-key (kbd "C-c d") 'md/duplicate-down)
     (global-set-key (kbd "C-c u") 'md/duplicate-up)
   #+END_SRC

** =whole-line-or-region=

   #+BEGIN_SRC emacs-lisp
     (use-package whole-line-or-region)
     (add-hook 'after-init-hook 'whole-line-or-region-mode)
   #+END_SRC

** =highlight-escape-sequences=

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-escape-sequences)
     (add-hook 'after-init-hook 'hes-mode)
   #+END_SRC

** =which-key=

   =which-key= displays the possible completions for a long keybinding. That's
   really helpful for some modes (like =projectile=, for example).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config (which-key-mode))
   #+END_SRC

* UI

  The =snazzy-theme= is snazzy.

  #+BEGIN_SRC emacs-lisp
    (use-package snazzy-theme
      :config
      (load-theme 'snazzy t))
  #+END_SRC

  The =moody= line is moody.

  #+BEGIN_SRC emacs-lisp
    (use-package moody
      :config
      (setq x-underline-at-descent-line t)
      (moody-replace-mode-line-buffer-identification)
      (moody-replace-vc-mode))
  #+END_SRC

  Use =minions= to hide all minor modes

  #+BEGIN_SRC emacs-lisp
    (use-package minions
      :config
      (setq minions-mode-line-lighter ""
            minions-mode-line-delimiters '("" . ""))
      (minions-mode 1))
  #+END_SRC

  Scale text easily with =default-text-scale=.

  #+BEGIN_SRC emacs-lisp
    (use-package default-text-scale
      :config
      (default-text-scale-mode 1))
  #+END_SRC

  A simple visible bell which works in all terminal types

  #+BEGIN_SRC emacs-lisp
    (use-package mode-line-bell
      :config
      (mode-line-bell-mode 1))
  #+END_SRC

  I don't usually use the menu or scroll bar, and they take up useful
  space.

  #+BEGIN_SRC emacs-lisp
    (tool-bar-mode 0)
    (menu-bar-mode 0)
    (scroll-bar-mode -1)
  #+END_SRC

  There's a tiny scroll bar that appears in the minibuffer window.
  This disables that:

  #+BEGIN_SRC emacs-lisp
    (set-window-scroll-bars (minibuffer-window) nil nil)
  #+END_SRC

  The default frame title isn't useful. This binds it to the name of
  the current project:

  #+BEGIN_SRC emacs-lisp
    (setq frame-title-format '((:eval (projectile-project-name))))
  #+END_SRC

* editing

  Configure newline behaviour

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)
  #+END_SRC

  Never use tabs. Tabs are the devilâ€™s whitespace.

  #+BEGIN_SRC emacs-lisp
    (setq-default indent-tabs-mode nil)
  #+END_SRC

  Prefer shallow indentation.

  #+BEGIN_SRC emacs-lisp
    (setq-default tab-width 2)
  #+END_SRC

  String utilities missing from core emacs.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/string-all-matches (regex str &optional group)
      "Find all matches for `REGEX' within `STR', returning the full
    match string or group `GROUP'."
      (let ((result nil)
            (pos 0)
            (group (or group 0)))
        (while (string-match regex str pos)
          (push (match-string group str) result)
          (setq pos (match-end group)))
        result))
  #+END_SRC

  Delete the current file and buffer.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/delete-this-file ()
      "Delete the current file, and kill the buffer."
      (interactive)
      (unless (buffer-file-name)
        (error "No file is currently being edited"))
      (when (yes-or-no-p (format "Really delete '%s'?"
                                 (file-name-nondirectory buffer-file-name)))
        (delete-file (buffer-file-name))
        (kill-this-buffer)))
  #+END_SRC

  Rename the current file.

  #+BEGIN_SRC emacs-lisp
    (defun mrw/rename-this-file-and-buffer (new-name)
      "Renames both current buffer and file it's visiting to
    NEW-NAME."
      (interactive "sNew name: ")
      (let ((name (buffer-name))
            (filename (buffer-file-name)))
        (unless filename
          (error "Buffer '%s' is not visiting a file!" name))
        (progn
          (when (file-exists-p filename)
            (rename-file filename new-name 1))
          (set-visited-file-name new-name)
          (rename-buffer new-name))))
  #+END_SRC
